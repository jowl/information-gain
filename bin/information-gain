#!/usr/bin/env ruby

$LOAD_PATH << File.join(__dir__, '..', 'lib')

require 'json'
require 'csv'
require 'optparse'

require 'entropy_calculator'
require 'information_gain_calculator'
require 'input'

options = {
  measure: :gain,
  format: :json,
}
option_parser = OptionParser.new do |opts|
  opts.on('--label PROPERTY', 'The label property') { |v| options[:label_property] = v }
  opts.on('--group A,B,C', Array, 'Group by features') { |v| options[:group_features] = v }
  opts.on('--measure MEASURE', %i[gain intrinsic ratio], %(The type of measure to produce (default #{options[:measure]}))) { |v| options[:measure] = v }
  opts.on('--format FORMAT', %i[json csv tsv], %(Input data format (default #{options[:format]}))) { |v| options[:format] = v }
end
option_parser.parse!
unless options[:label_property]
  abort sprintf(%(--label is required\n%s), option_parser.help)
end

data = Input.create(options[:format], $stdin)

calculators = Hash.new { |h,k| h[k] = InformationGainCalculator.new(options[:label_property]) }

group_features = options[:group_features]
data.each do |record|
  key = nil
  if group_features
    key = group_features.map { |k| record[k] }
  end
  calculator = calculators[key]
  calculator << record
end

headers = [options[:measure], *%w[feature entropy]]
headers << 'group' if group_features
$stdout.puts headers.join("\t")
calculators.each do |key, calculator|
  values = case options[:measure]
  when :gain then calculator.information_gains
  when :intrinsic then calculator.intrinsic_values
  when :ratio then calculator.information_gain_ratios
  end
  values.sort_by { |_, value| -value }.each do |feature, value|
    columns = [sprintf('%.3f', value), feature, sprintf('%.3f', calculator.entropy)]
    columns << key if group_features
    $stdout.puts columns.join("\t")
  end
end
