#!/usr/bin/env ruby

require 'json'
require 'optparse'

class EntropyCalculator
  def initialize(label_property)
    @label_property = label_property
    @label_counts = Hash.new(0)
  end

  def <<(object)
    @label_counts[object[@label_property]] += 1
  end

  def labels
    @label_counts.keys
  end

  def instances
    @label_counts.values.reduce(:+)
  end

  def entropy
    total = instances
    @label_counts.reduce(0) do |acc, (_, count)|
      fraction = count.fdiv(total)
      acc - fraction * Math.log2(fraction)
    end
  end
end

class InformationGainCalculator
  def initialize(label_property)
    @label_property = label_property
    @entropy_calculator = EntropyCalculator.new(label_property)
    @feature_entropy_calculators = Hash.new do |h, feature|
      h[feature] = Hash.new { |hh, val| hh[val] = EntropyCalculator.new(label_property) }
    end
  end

  def <<(object)
    object.each do |key, value|
      if key == @label_property
        @entropy_calculator << object
      else
        @feature_entropy_calculators[key][value] << object
      end
    end
  end

  def entropy
    @entropy_calculator.entropy
  end

  def information_gains
    total_entropy = entropy
    total_instances = @entropy_calculator.instances
    @feature_entropy_calculators.each_with_object({}) do |(feature, calculators), h|
      h[feature] = total_entropy - calculators.reduce(0) do |acc, (_, calculator)|
        acc + calculator.instances.fdiv(total_instances) * calculator.entropy
      end
    end
  end

  def intrinsic_values
    total_instances = @entropy_calculator.instances
    @feature_entropy_calculators.each_with_object({}) do |(feature, calculators), h|
      h[feature] = calculators.reduce(0) do |acc, (_, calculator)|
        fraction = calculator.instances.fdiv(total_instances)
        acc - fraction * Math.log2(fraction)
      end
    end
  end

  def information_gain_ratios
    information_gains.merge(intrinsic_values) { |_, gain, value| value.zero? ? 0.0 : gain / value }
  end
end

options = {
  measure: :gain,
}
option_parser = OptionParser.new do |opts|
  opts.on('--label PROPERTY', 'The label property') { |v| options[:label_property] = v }
  opts.on('--measure MEASURE', %i[gain intrinsic ratio], %(The type of measure to produce (default #{options[:measure]}))) { |v| options[:measure] = v }
end
option_parser.parse!
unless options[:label_property]
  abort sprintf(%(--label is required\n%s), option_parser.help)
end

calculator = InformationGainCalculator.new(options[:label_property])

STDIN.each do |line|
  calculator << JSON.parse(line)
end

values = case options[:measure]
when :gain then calculator.information_gains
when :intrinsic then calculator.intrinsic_values
when :ratio then calculator.information_gain_ratios
end

$stderr.puts sprintf(%(%.3f\ttotal entropy for %p), calculator.entropy, options[:label_property])
$stderr.puts
$stdout.puts sprintf(%(%s\tfeature), options[:measure])
$stderr.puts sprintf(%(%s\t-------), '-' * options[:measure].size)
begin
values.sort_by { |_, value| -value }.each do |feature, value|
  $stdout.puts sprintf(%(%.3f\t%s), value, feature)
end
rescue
  $stdout.puts JSON.dump(values)
end
